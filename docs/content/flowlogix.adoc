:jbake-title: Flow Logix Jakarta EE Components
:jbake-type: page_toc
:jbake-status: published
:jbake-keywords: docs jee jakarta-ee jakartaee dao jpalazydatamodel primefaces jpa components cdi java-ee javaee lazydatamodel

:toc:

[[section-introduction-and-features]]
== Introduction and Features
.Why another utility or component library?
FlowLogix provides a few remaining missing pieces in what is covered by Jakarta EE, PrimeFaces, OmniFaces, Apache Shiro and other very popular software.

.What are the features provided?
FlowLogix Jakarta EE library fills in the last few gaps that are left over in PrimeFaces, OmniFaces and Jakarta EE itself, including:

* Provides automatic DAO functionality with delegation and without inheritance
* Adds Type-safe Native SQL query with JPA via generics
* Declares Jakarta Faces PROJECT_STAGE development mode automatically
* Automatically uses minified versions of assets with Jakarta Faces
* Provides easy and automatic initialization of OmniFaces' UnmappedResourceHandler
* Easier-to-use JPA Lazy Data Model for PrimeFaces
* Automatically includes PrimeFaces font mime types in your web applications, preventing warnings and extra entries in your web.xml
* Convert strings to arbitrary types on a best-effort basis
* Transforms names between javax and jakarta namespaces
* Checks if objects are truly serializable by testing them
* Easy Transform Streams to Strings
* Simplify manipulation of ShrinkWrap archives including assets

[[section-architecture]]
=== Where does FlowLogix fit into your application architecture?
.Is it a framework?
No. FlowLogix fits within the Jakarta EE design philosophy and works with MicroProfile, Jakarta EE, OmniFaces and PrimeFaces ecosystem. FlowLogix tries to be the least intrusive, automatic and with the fewest requirements possible.

.What are the design principles?
Simplicity is the #1 principal. FlowLogix doesn't make you inherit from base classes or interfaces, unless absolutely necessary. Annotations are also used sparingly, being careful not to introduce any unnecessary cognitive load and complexity.

.Project Lombok is mentioned a lot. Is it required?
No. Although the library itself uses Lombok to avoid boilerplate code, it is completely optional to the user, and is not required to be a dependency of user code. Having said that, even though Java itself currently has lots of features only available with Lombok in prior years, Lombok still has many features not available in Java today, and is very useful and highly recommended.

[[section-installation]]
== Installation and Compatibility
=== Compatibility
FlowLogix 5.x is compatible with Java 11+ and Java EE 8, Jakarta EE 8 and later. Jakarta EE 9 and later (jakarta.* namespace) is available via the `jakarta` maven classifier. +
FlowLogix 6.x/7.x is compatible with Java 17+ and Jakarta EE 9 and later. No classifier is required.

=== Installation
Artifacts are available in the Sonatype's
link:https://central.sonatype.com/search?smo=true&q=com.flowlogix&sort=published[Maven Central repository^].
Both 5.x and 6.x snapshots are available in the
link:https://s01.oss.sonatype.org/content/repositories/snapshots/com/flowlogix/[Maven Central snapshot^] repository
[source,xml]
.Maven Example (Jakarta EE Components)
----
include::../../jakarta-ee/jee-examples/pom.xml[tags=dependenciesStart,indent=0]
include::../../jakarta-ee/jee-examples/pom.xml[tags=jeeDependency,indent=4]
include::../../jakarta-ee/jee-examples/pom.xml[tags=dependenciesEnd,indent=0]
----
[source,xml]
.Maven Example (PrimeFaces JPA LazyDataModel)
----
include::../../jakarta-ee/jee-examples/pom.xml[tags=dependenciesStart,indent=0]
include::../../jakarta-ee/jee-examples/pom.xml[tags=datamodelDependency,indent=4]
include::../../jakarta-ee/jee-examples/pom.xml[tags=dependenciesEnd,indent=0]
----

=== Flow Logix BOM
Flow Logix includes an easy way to declare all the required dependency versions, via the Maven Bill of Materials.
[source,xml]
.Example
----
include::../../jakarta-ee/jee-examples/pom.xml[tags=depManagementStart,indent=0]
include::../../jakarta-ee/jee-examples/pom.xml[tags=bomUsage,indent=8]
include::../../jakarta-ee/jee-examples/pom.xml[tags=depManagementEnd,indent=0]
----
See the link:https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#bill-of-materials-bom-poms[Maven Documentation^] for more information on BOMs

[[section-dev-guide]]
== Developer's Guide
[[section-jee]]
=== FlowLogix Jakarta EE Components
[[section-daohelper]]
==== `DaoHelper` for JPA: Delegation-based Helper for Data Access Objects and business logic
There are many ways to implement the Data-Access-Object pattern in Java. Most of them require to implement an interface, have some kind of bytecode generation magic or inherit from a base class. FlowLogix takes a different approach. The amount of magic is totally up to the developers. If none of the below approaches work, your DAO can simply inherit from `InheritableDaoHelper`, and initialize the `daoHelper` protected field in your `@PostConstruct` method.

You can leverage Project Lombok @Delegate annotation to transparently implement Data Access Objects without any specific requirements. Alternatively, developers can write manual forwarder methods, dynamic proxies, or
other bytecode generators to delegate to `DaoHelper` from an interface.

Recommended approach is to use Lombok's `@Delegate` annotation. This introduces the fewest amount of magic, results in the least amount of code, and absolute minimum (if any) boilerplate.

`DaoHelper` can also be `@Inject` ed and it will infer the `EntityManager` via CDI. If default CDI producer for the EntityManager is insufficient, `@EntityManagerSelector` annotation can be used to specify qualifiers for non-default `EntityManager` producer

`DaoHelper` is Serializable and thus can be used inside `@ViewScoped` beans, for example.

_Fluent Builder_ pattern can be used to create `DaoHelper` object, which requires EntityManager `Supplier` and entity `Class`.

.Why does `DaoHelper` take `Supplier` as a parameter instead of `EntityManager` directly?
That's Because `EntityManager` is not initialized when the object is created. `Supplier` lets you delay the initialization of `DaoHelper` until `EntityManager` is actually needed at run-time and is already initialized. This is why `InheritableDAOHelper` needs to be initialized in `@PostConstruct` method instead of the constructor.

.Where are `find()` and related methods?
These methods are built into the EntityManager and can be accessed that way (see the "more complete" example below). There is no need for DaoHelper to provide them. If more functionality related to `find()` is desired, https://deltaspike.apache.org[Apache DeltaSpike^] project is a wonderful addition to your architecture and will satisfy those needs.

[source,java]
.Simple DAO Example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/ExampleDAO.java[tags=simpleExampleDAO,indent=0]
----
[source,java]
.Injected DAO example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/InjectedDAO.java[tags=injectedExampleDAO,ident=0]
----
[source,java]
.Non-Default annotation example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/NonDefault.java[tags=nonDefault,indent=0]
----
[source,java]
.Non-Default EntityManager injection example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/InjectedEntityManager.java[tags=injectedEntityManager]
----
[source,java]
.Injected DAO with non-default EntityManager
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/InjectedNonDefaultDAO.java[tags=injectedNonDefaultExampleDAO,ident=0]
----
[source,java]
.More complete DAO example that forwards `EntityManager` methods
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/ExampleDelegateDAO.java[tags=delegateDAO]
----
[source,java]
.Non-default EntityManager Producer example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/EntityManagerProducer.java[tags=nonDefaultEntityProducer,ident=0]
----
NOTE: `@NonDefault` annotation can be removed to use it as a Default producer. If there is only one Persistence Unit, `unitName` can be also omitted.
[source,java]
.EJB Stateless EntityManager Producer example (optimization)
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/StatelessEntityManagerProducer.java[tags=statelessEntityProducer,ident=0]
----
The example above works well if `@RequestScope` is unavailable and may work better because of EJB bean pooling optimizations.
[source,java]
.Inherited DaoHelper example (not recommeded)
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/InheritedDAO.java[tags=inheritedDAO]
----

.Enhanced Finder and count methods
`findAll()`, `findRange()` and `count()` take an optional argument to enhance the queries, which can specify JPA `queryCriteria`. This takes a form of `builder -> builder.queryCriteria().countQueryCriteria().build()`. There are also `build` and `accept` convenience methods in  `QueryEnhancement` interface that can be passed via a method reference instead of a builder. `ParameterFunction` interface can be used to extract common parameters for both `count()` and `find()` methods, or customize individual methods as required.
[source,java]
.Enhanced query and hints example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/UserDAO.java[tags=daoParameters,indent=0]
----
[source,java]
.Enhanced query with customized parameters
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/UserDAO.java[tags=daoExtractedParameters,indent=0]
----

[[section-nativequery]]
==== JPA: Generics-based Type-safe native query
`DaoHelper` has a convenience method `createNativeQuery()` which will return `TypedNativeQuery` object. This is a thin wrapper over JPA's `Query` object, however it's `getResult*()` methods return typed results via generics, which avoids casting and makes the results easier and safer to use.
[source,java]
.Native Query Example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/jeedao/UserDAO.java[tags=nativeQuery,indent=0]
----

[[section-jsf]]
==== Jakarta Faces: Automated PROJECT_STAGE configuration
Jakarta Faces runs in production mode by default. However, most applications set up development mode by modifiying `web.xml`. Traditionally, it's been difficult to set up environment-based switching from development to production mode. FlowLogix sets this up automatically via `web-fragment.xml` and allows JNDI-based switch to production mode.

NOTE: Special entries in `web.xml`, `glassfish-web.xml` or any other container-specific configuration are no longer required and can be removed.

Below is an example of setting up production mode with Payara and GlassFish with Jakarta EE 9 or later:
[source,shell]
----
$ asadmin create-custom-resource --resType=java.lang.String --factoryClass=org.glassfish.resources.custom.factory.PrimitivesAndStringFactory faces/ProjectStage
$ asadmin set resources.custom-resource.faces/ProjectStage.property.value=Production
----
With Jakarta EE or Java EE 8 and earlier, replace `faces/` with `jsf/`.

==== Jakarta Faces: Use minified assets automatically in production mode
Most front-end applications want to use minified versions of their assets, such as JavaScript and CSS files in production (i.e. any non-development) modes. FlowLogix allows this via `MinimizedHandler` which will automatically insert `min` prefix into the appropriate assets, for example `resource.js -> resource.min.js` and `resource.css -> resource.min.css`.
This is configurable via web.xml parameters `com.flowlogix.MINIMIZED_PREFIX` and `com.flowlogix.MINIMIZED_FILE_TYPES`

`MinimizedHandler` works with build tools that generate minified versions of resources automatically, such as https://samaxes.github.io/minify-maven-plugin[maven minify plugin^].

[source,xml]
.faces-config.xml
----
<application>
    <resource-handler>com.flowlogix.ui.MinimizedHandler</resource-handler>
</application>
----
Any configured Jakarta Faces resources are resolved to their minified versions
[source,xml]
.index.xhtml: automatically resolves to `myjavascript.min.js`
----
<h:outputScript name="myjavascript.js"/>
----
[source,css]
.Importing automatically resolves to `other.min.css`
----
@import url("#{resource['css/other.css']}");
----
By default, only resources with css and js extensions are resolved to their minified versions. The `min` extension is inserted prior to their original extension.
[source,xml]
.web.xml: change the default `.min` to `.minimized`
----
<context-param>
    <param-name>com.flowlogix.MINIMIZED_PREFIX</param-name>
    <param-value>minimized</param-value>
</context-param>
----
The above example changes resolution from `mycss.css` -> `mycss.min.css` to `mycss.css` -> `mycss.minimized.css`

[source,xml]
.Override extensions that are resolved to their minimized versions
----
<!-- Optional, default is "css, js" -->
<context-param>
    <param-name>com.flowlogix.MINIMIZED_FILE_TYPES</param-name>
    <param-value>css, js, tsx, sass, scss, less</param-value>
</context-param>
----

[[section-omnifaces]]
==== OmniFaces: Automatic initialization of _UnmappedResourceHandler_
In order to initialize https://showcase.omnifaces.org/resourcehandlers/UnmappedResourceHandler[OmniFaces' UnmappedResourceHandler], both `web.xml` `servlet-mapping` and `faces.xml` entries are ordinarily required. FlowLogix automates more complicated `web.xml` requirements by configuring the servlet container to include all unmapped resources. This alleviates requirement to specify `Faces Servlet` mapping in your `web.xml` file at all. In order to enable this, add the below context parameter in `web.xml`:
[source,xml]
----
<context-param>
    <param-name>com.flowlogix.add-unmapped-resources</param-name>
    <param-value>true</param-value>
</context-param>
----

[[section-primefaces]]
==== PrimeFaces: Font mime-types automatically included
PrimeFaces automatically includes fonts as part of the application. However, the file extensions of these fonts are not usually included in most servlet containers by default. FlowLogix adds those mime types automatically and prevents the warnings such as below from appearing in log files:
[source]
----
 WARNING: JSF1091: No mime type could be found for file font1.woff2
----
This way, no extra `mime-mapping` entries are required in `web.xml`

[[section-utils]]
==== Type Converter, Serialization Tester and Integration Test Helper
.Convert Strings to arbitrary types
Most classes that can be constructed from `String` include `valueOf(String)` method by convention.
`TypeConverter` class uses this to generically convert a String to any type specified, thus dramatically reducing the code required.
If unable to convert the class, an exception is thrown. +
`TypeConverter` specifically does _not_ support custom converters for simplicity.
If those are desired, other libraries do a great job of handling custom converters, including Jakarta Faces' Converters.
[source,java]
.Generically and dynamically transform a `String` to any class, throws an exception if failed
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/util/TypeConverterDemo.java[tags=typeConvert,indent=0]
----
[source,java]
.Convert and check if returned value matches the input after the conversion, without throwing any exceptions
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/util/TypeConverterDemo.java[tags=checkTypeConvert,indent=0]
----

.Transform java -> jakarta namespace at run-time (jakartify)
FlowLogix provides a convenience method for converting strings from `javax` to `jakarta` namespace:
[source,java]
.Servlet example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/ui/JakartifyDemo.java[tags=jakartifyServlet,indent=0]
----
[source,java]
.Jakarta Faces example
----
include::../../jakarta-ee/flowlogix-jee/src/demo/java/com/flowlogix/demo/ui/JakartifyDemo.java[tags=jakartifyError,indent=0]
----
FlowLogix automatically detects which environment it's in, and converts `javax`-based names into `jakarta`-based namespace accordingly. Keep in mind that the environment check occurs at run-time, and not compile time. This method works not only for classes, but also for error messages and other strings.

The `jakartify()` utility is particularly useful in scenarios where maven `shade` plugin is used to produce both `javax` and `jakarta`-based JAR artifacts. It allows to use same source code for both and dynamically produce correct strings without additional shade plugins or complex regular expressions.

.Serialization Tester
Generic `serializeAndDeserialize()` can be used to check the true ability to serialize a class. It returns the object passed after going through serialization and deserialization, so the new state can be checked for correctness.

.Read String from Stream easily
FlowLogix provides an easy way to read a String from any input stream:
[source,java]
----
String s = Streams.readString(strm);
----

.Simplify ShrinkWrap archive manipulation for testing
`ShrinkWrapManupulator` class has a few utility methods that make Arquillian tests easier. +
Some tests require TLS/SSL to execute properly. Arquillian uses plain http by default. To facilitate tests that require TLS/SSL, `toHttpsURL(url)` takes a URL and converts it to it's https equivalent, taking the `sslPort` system property into account. Default port is 8181

.Below, toHttpsUrl("http://host/index.html") will return "https://host:8282/index.html"
[source,shell]
----
$ mvn verify -DsslPort=8282
----
`webXmlXPath()` takes a `List<Action>` and will manipulate archive's `web.xml` to achieve the desired test configuration. For example, if Jakarta Faces production mode is desired for the particular archive, `web.xml` `context-param` is changed below:
[source,java]
----
@Deployment
public static WebArchive deploy() {
    WebArchive archive = ShrinkWrap.create(...);
    new ShrinkWrapManipulator().webXmlXPath(archive, List.of(new Action(
        getContextParamValue(jakartify("javax.faces.PROJECT_STAGE")),
        node -> node.setTextContent("Production"))));
}
----
`getContextParamValue()` is a shorthand to produce XPath for `web.xml` context parameter (`<context-param>`) element:
[source,xml]
----
//web-app/context-param[param-name = 'jakarta.faces.PROJECT_STAGE']/param-value
----
The second parameter is DOM `Node` class `Consumer` lambda, which allows for manipulation of the DOM element directly by the user. +
Above, we also combine `web.xml` manipulation with `jakartify` to be compatible with both Jakarta EE 8 or 9, if desired.
[source,java]
.Example of manipulation of `persistence.xml` file
----
TBD
----


[[section-jpa-lazymodel]]
=== FlowLogix PrimeFaces Lazy Data Model backed by JPA
.An easier alternative to PrimeFaces JPA Lazy Data model
PrimeFaces provides a convenient https://www.javadoc.io/doc/org.primefaces/primefaces/latest/org/primefaces/model/JpaLazyDataModel.html[wrapper^] for the Lazy DataModel. However, FlowLogix `JPALazyDataModel` predates it and thus has a "head start" in features, compactness and ease of use. It also utilizes `DaoHelper` classes and methodology to make JPA lazy data model even easier and with a lot less code.
[source,xhtml]
.userviewer.xhtml
----
<p:dataTable lazy="true" value="#{userViewer.lazyModel}" var="user">
    ... specify columns as usual ...
</p:dataTable>
----
[source,java]
.UserViewer.java
----
@Named
@ViewScoped
public class UserViewer implements Serializable {
include::../../jakarta-ee/jee-examples/src/main/java/com/flowlogix/examples/data/UserViewer.java[tags="simpleLazyDataModelUsage,!simpleOptionalLazyDataModelUsage"]
}
----
Above we created a model with case-insensitive filtering.

`JPALazyDataModel` only requires `entityClass` to work, everything else is optional:

* entityManager: Provide entity manager `Supplier`. Default is injected via CDI
* entityManagerQualifiers: Provides a list of qualifier annotations to select the correct EntityManager for injection
* sorter: Apply custom sort criteria
* filter: Apply custom filter criteria
* optimizer: Apply custom JPA hints, works with `DaoHelper`
* converter: `Function` that converts String representation of a primary key into an primary key object. Needed only if the default is insufficient.
* keyConverter: `Function` that converts an entity object into primary key in `String` form. Needed only if the default is insufficient.

Let's use custom sort criteria to add address to the default sort criteria:
[source,java]
----
JPALazyDataModel.create(builder -> builder.sorter(UserViewer::sorter).entityXXX().build());

private static boolean sorter(SortData sortData, CriteriaBuilder cb, Root<UserEntity> root) {
        sortData.getSortOrder().add(cb.asc(root.get(UserEntity_.address)));
        return false;
}
----
Let's use custom filter criteria using `replaceFilter` convenience method. Here we make sure that only zip codes greater than that in the filter are returned:
[source,java]
----
JPALazyDataModel.create(builder -> builder.filter(UserViewer::filter).entityXXX().build());

private static void filter(Map<String, FilterData> filters, CriteriaBuilder cb, Root<UserEntity> root) {
        replaceFilter(filters, UserEntity_.zipCode.getName(),
                (Predicate predicate, Integer value) -> cb.greaterThan(root.get(UserEntity_.zipCode), value));
}
----
Optimizer hints can be used to batch fetch dependent entities. The `Function` should return the same `TypedQuery` instance it was passed in the _Fluent_ manner.
[source,java]
----
private static TypedQuery<UserEntity> optimizer(TypedQuery<UserEntity> query) {
    return query.setHint(QueryHints.BATCH, getResultField("userSettings"))
        .setHint(QueryHints.BATCH_TYPE, BatchFetchType.IN)
        .setHint(QueryHints.BATCH, getResultField("alternateEmails"));
}
----

== API Reference
FlowLogix features a full API references:

link:https://javadoc.io/doc/com.flowlogix/flowlogix-jee[Jakarta EE Components API Reference^] +
link:https://javadoc.io/doc/com.flowlogix/flowlogix-datamodel[PrimeFaces JPA Lazy Data Model API Reference^]
